{"version":3,"sources":["webpack://echarts-wordcloud/webpack/universalModuleDefinition","webpack://echarts-wordcloud/./src/WordCloudSeries.js","webpack://echarts-wordcloud/./src/WordCloudView.js","webpack://echarts-wordcloud/./src/layout.js","webpack://echarts-wordcloud/./src/wordCloud.js","webpack://echarts-wordcloud/./index.js","webpack://echarts-wordcloud/external \"echarts\"","webpack://echarts-wordcloud/webpack/bootstrap","webpack://echarts-wordcloud/webpack/runtime/make namespace object","webpack://echarts-wordcloud/webpack/startup"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;;;ACV+C;;AAE/C,mCAAyB;;AAEzB;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA,yBAAyB,yCAA+B;AACxD;AACA,SAAS;AACT,uBAAuB,sBAAY;AACnC;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;AC1D8C;;AAE/C,iCAAuB;;AAEvB;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,6BAA6B,8BAAoB;AACjD,uBAAuB,wCAA8B;AACrD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;;AAEA;;AAEA,mDAAmD,wCAA8B;AACjF;AACA,aAAa;AACb,+CAA+C,wCAA8B;AAC7E;AACA,aAAa;;AAEb,YAAY,4CAAkC;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,CAAC;;;ACxED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,2CAA2C,2BAA2B;;AAEtE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAqD;;AAErD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,kEAAkE;AAClE;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,EAAE,6CAAe,SAAS,E;;ACxpCqB;;AAEpB;AACF;;AAEoB;;AAE7C,KAAK,kBAAiC;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAsB;AACtB;AACA,uBAAuB,sCAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,MAAqB;AAC7B;AACA;AACA;AACA;AACA;AACA,2BAA2B,kCAAwB;AACnD;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;AACL,CAAC;;AAED,sCAA4B;AAC5B,8BAA8B;AAC9B,KAAK,8BAAoB;;AAEzB;;AAEA,IAAI,2BAAiB;AACrB;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA,qBAAqB,2BAAiB;AACtC;AACA,mCAAmC,qCAA2B;AAC9D;AACA,SAAS;AACT;AACA,CAAC;;;AC5LwB;;;;;;;;;;;ACAzB,iE;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCrBA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;UCNA;UACA;UACA;UACA","file":"echarts-wordcloud.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"echarts\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"echarts\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"echarts-wordcloud\"] = factory(require(\"echarts\"));\n\telse\n\t\troot[\"echarts-wordcloud\"] = factory(root[\"echarts\"]);\n})(self, function(__WEBPACK_EXTERNAL_MODULE_echarts_lib_echarts__) {\nreturn ","import * as echarts from 'echarts/lib/echarts';\r\n\r\necharts.extendSeriesModel({\r\n\r\n    type: 'series.wordCloud',\r\n\r\n    visualStyleAccessPath: 'textStyle',\r\n    visualStyleMapper: function (model) {\r\n        return {\r\n            fill: model.get('color')\r\n        };\r\n    },\r\n    visualDrawType: 'fill',\r\n\r\n    optionUpdated: function () {\r\n        var option = this.option;\r\n        option.gridSize = Math.max(Math.floor(option.gridSize), 4);\r\n    },\r\n\r\n    getInitialData: function (option, ecModel) {\r\n        var dimensions = echarts.helper.createDimensions(option.data, {\r\n            coordDimensions: ['value']\r\n        });\r\n        var list = new echarts.List(dimensions, this);\r\n        list.initData(option.data);\r\n        return list;\r\n    },\r\n\r\n    // Most of options are from https://github.com/timdream/wordcloud2.js/blob/gh-pages/API.md\r\n    defaultOption: {\r\n\r\n        maskImage: null,\r\n\r\n        // Shape can be 'circle', 'cardioid', 'diamond', 'triangle-forward', 'triangle', 'pentagon', 'star'\r\n        shape: 'circle',\r\n\r\n        left: 'center',\r\n\r\n        top: 'center',\r\n\r\n        width: '70%',\r\n\r\n        height: '80%',\r\n\r\n        sizeRange: [12, 60],\r\n\r\n        rotationRange: [-90, 90],\r\n\r\n        rotationStep: 45,\r\n\r\n        gridSize: 8,\r\n\r\n        drawOutOfBound: false,\r\n\r\n        textStyle: {\r\n            fontWeight: 'normal'\r\n        }\r\n    }\r\n});\r\n","import * as echarts from 'echarts/lib/echarts';\r\n\r\necharts.extendChartView({\r\n\r\n    type: 'wordCloud',\r\n\r\n    render: function (seriesModel, ecModel, api) {\r\n        var group = this.group;\r\n        group.removeAll();\r\n\r\n        var data = seriesModel.getData();\r\n\r\n        var gridSize = seriesModel.get('gridSize');\r\n\r\n        seriesModel.layoutInstance.ondraw = function (text, size, dataIdx, drawn) {\r\n            var itemModel = data.getItemModel(dataIdx);\r\n            var textStyleModel = itemModel.getModel('textStyle');\r\n\r\n            var textEl = new echarts.graphic.Text({\r\n                style: echarts.helper.createTextStyle(textStyleModel),\r\n                scaleX: 1 / drawn.info.mu,\r\n                scaleY: 1 / drawn.info.mu,\r\n                x: (drawn.gx + drawn.info.gw / 2) * gridSize,\r\n                y: (drawn.gy + drawn.info.gh / 2) * gridSize,\r\n                rotation: drawn.rot\r\n            });\r\n            textEl.setStyle({\r\n                x: drawn.info.fillTextOffsetX,\r\n                y: drawn.info.fillTextOffsetY + size * 0.5,\r\n                text: text,\r\n                verticalAlign: 'middle',\r\n                fill: data.getItemVisual(dataIdx, 'style').fill,\r\n                fontSize: size\r\n            });\r\n\r\n            group.add(textEl);\r\n\r\n            data.setItemGraphicEl(dataIdx, textEl);\r\n\r\n            textEl.ensureState('emphasis').style = echarts.helper.createTextStyle(itemModel.getModel(['emphasis', 'textStyle']), {\r\n                state: 'emphasis'\r\n            });\r\n            textEl.ensureState('blur').style = echarts.helper.createTextStyle(itemModel.getModel(['blur', 'textStyle']), {\r\n                state: 'blur'\r\n            });\r\n\r\n            echarts.helper.enableHoverEmphasis(\r\n                textEl,\r\n                itemModel.get(['emphasis', 'focus']),\r\n                itemModel.get(['emphasis', 'blurScope'])\r\n            );\r\n\r\n            textEl.stateTransition = {\r\n                duration: seriesModel.get('animation') ? seriesModel.get(['stateAnimation', 'duration']) : 0,\r\n                easing: seriesModel.get(['stateAnimation', 'easing'])\r\n            };\r\n            // TODO\r\n            textEl.__highDownDispatcher = true;\r\n        };\r\n\r\n        this._model = seriesModel;\r\n    },\r\n\r\n    remove: function () {\r\n        this.group.removeAll();\r\n\r\n        this._model.layoutInstance.dispose();\r\n    },\r\n\r\n    dispose: function () {\r\n        this._model.layoutInstance.dispose();\r\n    }\r\n});\r\n","/*!\r\n * wordcloud2.js\r\n * http://timdream.org/wordcloud2.js/\r\n *\r\n * Copyright 2011 - 2013 Tim Chien\r\n * Released under the MIT license\r\n */\r\n\r\n'use strict';\r\n\r\n// setImmediate\r\nif (!window.setImmediate) {\r\n  window.setImmediate = (function setupSetImmediate() {\r\n    return window.msSetImmediate ||\r\n    window.webkitSetImmediate ||\r\n    window.mozSetImmediate ||\r\n    window.oSetImmediate ||\r\n    (function setupSetZeroTimeout() {\r\n      if (!window.postMessage || !window.addEventListener) {\r\n        return null;\r\n      }\r\n\r\n      var callbacks = [undefined];\r\n      var message = 'zero-timeout-message';\r\n\r\n      // Like setTimeout, but only takes a function argument.  There's\r\n      // no time argument (always zero) and no arguments (you have to\r\n      // use a closure).\r\n      var setZeroTimeout = function setZeroTimeout(callback) {\r\n        var id = callbacks.length;\r\n        callbacks.push(callback);\r\n        window.postMessage(message + id.toString(36), '*');\r\n\r\n        return id;\r\n      };\r\n\r\n      window.addEventListener('message', function setZeroTimeoutMessage(evt) {\r\n        // Skipping checking event source, retarded IE confused this window\r\n        // object with another in the presence of iframe\r\n        if (typeof evt.data !== 'string' ||\r\n            evt.data.substr(0, message.length) !== message/* ||\r\n            evt.source !== window */) {\r\n          return;\r\n        }\r\n\r\n        evt.stopImmediatePropagation();\r\n\r\n        var id = parseInt(evt.data.substr(message.length), 36);\r\n        if (!callbacks[id]) {\r\n          return;\r\n        }\r\n\r\n        callbacks[id]();\r\n        callbacks[id] = undefined;\r\n      }, true);\r\n\r\n      /* specify clearImmediate() here since we need the scope */\r\n      window.clearImmediate = function clearZeroTimeout(id) {\r\n        if (!callbacks[id]) {\r\n          return;\r\n        }\r\n\r\n        callbacks[id] = undefined;\r\n      };\r\n\r\n      return setZeroTimeout;\r\n    })() ||\r\n    // fallback\r\n    function setImmediateFallback(fn) {\r\n      window.setTimeout(fn, 0);\r\n    };\r\n  })();\r\n}\r\n\r\nif (!window.clearImmediate) {\r\n  window.clearImmediate = (function setupClearImmediate() {\r\n    return window.msClearImmediate ||\r\n    window.webkitClearImmediate ||\r\n    window.mozClearImmediate ||\r\n    window.oClearImmediate ||\r\n    // \"clearZeroTimeout\" is implement on the previous block ||\r\n    // fallback\r\n    function clearImmediateFallback(timer) {\r\n      window.clearTimeout(timer);\r\n    };\r\n  })();\r\n}\r\n\r\n  // Check if WordCloud can run on this browser\r\n  var isSupported = (function isSupported() {\r\n    var canvas = document.createElement('canvas');\r\n    if (!canvas || !canvas.getContext) {\r\n      return false;\r\n    }\r\n\r\n    var ctx = canvas.getContext('2d');\r\n    if (!ctx.getImageData) {\r\n      return false;\r\n    }\r\n    if (!ctx.fillText) {\r\n      return false;\r\n    }\r\n\r\n    if (!Array.prototype.some) {\r\n      return false;\r\n    }\r\n    if (!Array.prototype.push) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }());\r\n\r\n  // Find out if the browser impose minium font size by\r\n  // drawing small texts on a canvas and measure it's width.\r\n  var minFontSize = (function getMinFontSize() {\r\n    if (!isSupported) {\r\n      return;\r\n    }\r\n\r\n    var ctx = document.createElement('canvas').getContext('2d');\r\n\r\n    // start from 20\r\n    var size = 20;\r\n\r\n    // two sizes to measure\r\n    var hanWidth, mWidth;\r\n\r\n    while (size) {\r\n      ctx.font = size.toString(10) + 'px sans-serif';\r\n      if ((ctx.measureText('\\uFF37').width === hanWidth) &&\r\n          (ctx.measureText('m').width) === mWidth) {\r\n        return (size + 1);\r\n      }\r\n\r\n      hanWidth = ctx.measureText('\\uFF37').width;\r\n      mWidth = ctx.measureText('m').width;\r\n\r\n      size--;\r\n    }\r\n\r\n    return 0;\r\n  })();\r\n\r\n  // Based on http://jsfromhell.com/array/shuffle\r\n  var shuffleArray = function shuffleArray(arr) {\r\n    for (var j, x, i = arr.length; i;\r\n      j = Math.floor(Math.random() * i),\r\n      x = arr[--i], arr[i] = arr[j],\r\n      arr[j] = x) {}\r\n    return arr;\r\n  };\r\n\r\n  var WordCloud = function WordCloud(elements, options) {\r\n    if (!isSupported) {\r\n      return;\r\n    }\r\n\r\n    if (!Array.isArray(elements)) {\r\n      elements = [elements];\r\n    }\r\n\r\n    elements.forEach(function(el, i) {\r\n      if (typeof el === 'string') {\r\n        elements[i] = document.getElementById(el);\r\n        if (!elements[i]) {\r\n          throw 'The element id specified is not found.';\r\n        }\r\n      } else if (!el.tagName && !el.appendChild) {\r\n        throw 'You must pass valid HTML elements, or ID of the element.';\r\n      }\r\n    });\r\n\r\n    /* Default values to be overwritten by options object */\r\n    var settings = {\r\n      list: [],\r\n      fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"微軟正黑體\", ' +\r\n                  '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',\r\n      fontWeight: 'normal',\r\n      color: 'random-dark',\r\n      minSize: 0, // 0 to disable\r\n      weightFactor: 1,\r\n      clearCanvas: true,\r\n      backgroundColor: '#fff',  // opaque white = rgba(255, 255, 255, 1)\r\n\r\n      gridSize: 8,\r\n      drawOutOfBound: false,\r\n      origin: null,\r\n\r\n      drawMask: false,\r\n      maskColor: 'rgba(255,0,0,0.3)',\r\n      maskGapWidth: 0.3,\r\n\r\n      layoutAnimation: true,\r\n\r\n      wait: 0,\r\n      abortThreshold: 0, // disabled\r\n      abort: function noop() {},\r\n\r\n      minRotation: - Math.PI / 2,\r\n      maxRotation: Math.PI / 2,\r\n      rotationStep: 0.1,\r\n\r\n      shuffle: true,\r\n      rotateRatio: 0.1,\r\n\r\n      shape: 'circle',\r\n      ellipticity: 0.65,\r\n\r\n      classes: null,\r\n\r\n      hover: null,\r\n      click: null\r\n    };\r\n\r\n    if (options) {\r\n      for (var key in options) {\r\n        if (key in settings) {\r\n          settings[key] = options[key];\r\n        }\r\n      }\r\n    }\r\n\r\n    /* Convert weightFactor into a function */\r\n    if (typeof settings.weightFactor !== 'function') {\r\n      var factor = settings.weightFactor;\r\n      settings.weightFactor = function weightFactor(pt) {\r\n        return pt * factor; //in px\r\n      };\r\n    }\r\n\r\n    /* Convert shape into a function */\r\n    if (typeof settings.shape !== 'function') {\r\n      switch (settings.shape) {\r\n        case 'circle':\r\n        /* falls through */\r\n        default:\r\n          // 'circle' is the default and a shortcut in the code loop.\r\n          settings.shape = 'circle';\r\n          break;\r\n\r\n        case 'cardioid':\r\n          settings.shape = function shapeCardioid(theta) {\r\n            return 1 - Math.sin(theta);\r\n          };\r\n          break;\r\n\r\n        /*\r\n        To work out an X-gon, one has to calculate \"m\",\r\n        where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))\r\n        http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28\r\n        2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29\r\n        Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))\r\n        where t' equals to mod(t, 2PI/X);\r\n        */\r\n\r\n        case 'diamond':\r\n        case 'square':\r\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\r\n          // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D\r\n          // +0+..+2*PI\r\n          settings.shape = function shapeSquare(theta) {\r\n            var thetaPrime = theta % (2 * Math.PI / 4);\r\n            return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));\r\n          };\r\n          break;\r\n\r\n        case 'triangle-forward':\r\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\r\n          // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29\r\n          // %29%29%2C+t+%3D+0+..+2*PI\r\n          settings.shape = function shapeTriangle(theta) {\r\n            var thetaPrime = theta % (2 * Math.PI / 3);\r\n            return 1 / (Math.cos(thetaPrime) +\r\n                        Math.sqrt(3) * Math.sin(thetaPrime));\r\n          };\r\n          break;\r\n\r\n        case 'triangle':\r\n        case 'triangle-upright':\r\n          settings.shape = function shapeTriangle(theta) {\r\n            var thetaPrime = (theta + Math.PI * 3 / 2) % (2 * Math.PI / 3);\r\n            return 1 / (Math.cos(thetaPrime) +\r\n                        Math.sqrt(3) * Math.sin(thetaPrime));\r\n          };\r\n          break;\r\n\r\n        case 'pentagon':\r\n          settings.shape = function shapePentagon(theta) {\r\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 5);\r\n            return 1 / (Math.cos(thetaPrime) +\r\n                        0.726543 * Math.sin(thetaPrime));\r\n          };\r\n          break;\r\n\r\n        case 'star':\r\n          settings.shape = function shapeStar(theta) {\r\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 10);\r\n            if ((theta + 0.955) % (2 * Math.PI / 5) - (2 * Math.PI / 10) >= 0) {\r\n              return 1 / (Math.cos((2 * Math.PI / 10) - thetaPrime) +\r\n                          3.07768 * Math.sin((2 * Math.PI / 10) - thetaPrime));\r\n            } else {\r\n              return 1 / (Math.cos(thetaPrime) +\r\n                          3.07768 * Math.sin(thetaPrime));\r\n            }\r\n          };\r\n          break;\r\n      }\r\n    }\r\n\r\n    /* Make sure gridSize is a whole number and is not smaller than 4px */\r\n    settings.gridSize = Math.max(Math.floor(settings.gridSize), 4);\r\n\r\n    /* shorthand */\r\n    var g = settings.gridSize;\r\n    var maskRectWidth = g - settings.maskGapWidth;\r\n\r\n    /* normalize rotation settings */\r\n    var rotationRange = Math.abs(settings.maxRotation - settings.minRotation);\r\n    var minRotation = Math.min(settings.maxRotation, settings.minRotation);\r\n    var rotationStep = settings.rotationStep;\r\n\r\n    /* information/object available to all functions, set when start() */\r\n    var grid, // 2d array containing filling information\r\n      ngx, ngy, // width and height of the grid\r\n      center, // position of the center of the cloud\r\n      maxRadius;\r\n\r\n    /* timestamp for measuring each putWord() action */\r\n    var escapeTime;\r\n\r\n    /* function for getting the color of the text */\r\n    var getTextColor;\r\n    function random_hsl_color(min, max) {\r\n      return 'hsl(' +\r\n        (Math.random() * 360).toFixed() + ',' +\r\n        (Math.random() * 30 + 70).toFixed() + '%,' +\r\n        (Math.random() * (max - min) + min).toFixed() + '%)';\r\n    }\r\n    switch (settings.color) {\r\n      case 'random-dark':\r\n        getTextColor = function getRandomDarkColor() {\r\n          return random_hsl_color(10, 50);\r\n        };\r\n        break;\r\n\r\n      case 'random-light':\r\n        getTextColor = function getRandomLightColor() {\r\n          return random_hsl_color(50, 90);\r\n        };\r\n        break;\r\n\r\n      default:\r\n        if (typeof settings.color === 'function') {\r\n          getTextColor = settings.color;\r\n        }\r\n        break;\r\n    }\r\n\r\n    /* function for getting the classes of the text */\r\n    var getTextClasses = null;\r\n    if (typeof settings.classes === 'function') {\r\n      getTextClasses = settings.classes;\r\n    }\r\n\r\n    /* Interactive */\r\n    var interactive = false;\r\n    var infoGrid = [];\r\n    var hovered;\r\n\r\n    var getInfoGridFromMouseTouchEvent =\r\n    function getInfoGridFromMouseTouchEvent(evt) {\r\n      var canvas = evt.currentTarget;\r\n      var rect = canvas.getBoundingClientRect();\r\n      var clientX;\r\n      var clientY;\r\n      /** Detect if touches are available */\r\n      if (evt.touches) {\r\n        clientX = evt.touches[0].clientX;\r\n        clientY = evt.touches[0].clientY;\r\n      } else {\r\n        clientX = evt.clientX;\r\n        clientY = evt.clientY;\r\n      }\r\n      var eventX = clientX - rect.left;\r\n      var eventY = clientY - rect.top;\r\n\r\n      var x = Math.floor(eventX * ((canvas.width / rect.width) || 1) / g);\r\n      var y = Math.floor(eventY * ((canvas.height / rect.height) || 1) / g);\r\n\r\n      return infoGrid[x][y];\r\n    };\r\n\r\n    var wordcloudhover = function wordcloudhover(evt) {\r\n      var info = getInfoGridFromMouseTouchEvent(evt);\r\n\r\n      if (hovered === info) {\r\n        return;\r\n      }\r\n\r\n      hovered = info;\r\n      if (!info) {\r\n        settings.hover(undefined, undefined, evt);\r\n\r\n        return;\r\n      }\r\n\r\n      settings.hover(info.item, info.dimension, evt);\r\n\r\n    };\r\n\r\n    var wordcloudclick = function wordcloudclick(evt) {\r\n      var info = getInfoGridFromMouseTouchEvent(evt);\r\n      if (!info) {\r\n        return;\r\n      }\r\n\r\n      settings.click(info.item, info.dimension, evt);\r\n      evt.preventDefault();\r\n    };\r\n\r\n    /* Get points on the grid for a given radius away from the center */\r\n    var pointsAtRadius = [];\r\n    var getPointsAtRadius = function getPointsAtRadius(radius) {\r\n      if (pointsAtRadius[radius]) {\r\n        return pointsAtRadius[radius];\r\n      }\r\n\r\n      // Look for these number of points on each radius\r\n      var T = radius * 8;\r\n\r\n      // Getting all the points at this radius\r\n      var t = T;\r\n      var points = [];\r\n\r\n      if (radius === 0) {\r\n        points.push([center[0], center[1], 0]);\r\n      }\r\n\r\n      while (t--) {\r\n        // distort the radius to put the cloud in shape\r\n        var rx = 1;\r\n        if (settings.shape !== 'circle') {\r\n          rx = settings.shape(t / T * 2 * Math.PI); // 0 to 1\r\n        }\r\n\r\n        // Push [x, y, t]; t is used solely for getTextColor()\r\n        points.push([\r\n          center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI),\r\n          center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) *\r\n            settings.ellipticity,\r\n          t / T * 2 * Math.PI]);\r\n      }\r\n\r\n      pointsAtRadius[radius] = points;\r\n      return points;\r\n    };\r\n\r\n    /* Return true if we had spent too much time */\r\n    var exceedTime = function exceedTime() {\r\n      return ((settings.abortThreshold > 0) &&\r\n        ((new Date()).getTime() - escapeTime > settings.abortThreshold));\r\n    };\r\n\r\n    /* Get the deg of rotation according to settings, and luck. */\r\n    var getRotateDeg = function getRotateDeg() {\r\n      if (settings.rotateRatio === 0) {\r\n        return 0;\r\n      }\r\n\r\n      if (Math.random() > settings.rotateRatio) {\r\n        return 0;\r\n      }\r\n\r\n      if (rotationRange === 0) {\r\n        return minRotation;\r\n      }\r\n\r\n      return minRotation + Math.round(Math.random() * rotationRange / rotationStep) * rotationStep;\r\n    };\r\n\r\n    var getTextInfo = function getTextInfo(word, weight, rotateDeg) {\r\n      // calculate the acutal font size\r\n      // fontSize === 0 means weightFactor function wants the text skipped,\r\n      // and size < minSize means we cannot draw the text.\r\n      var debug = false;\r\n      var fontSize = settings.weightFactor(weight);\r\n      if (fontSize <= settings.minSize) {\r\n        return false;\r\n      }\r\n\r\n      // Scale factor here is to make sure fillText is not limited by\r\n      // the minium font size set by browser.\r\n      // It will always be 1 or 2n.\r\n      var mu = 1;\r\n      if (fontSize < minFontSize) {\r\n        mu = (function calculateScaleFactor() {\r\n          var mu = 2;\r\n          while (mu * fontSize < minFontSize) {\r\n            mu += 2;\r\n          }\r\n          return mu;\r\n        })();\r\n      }\r\n\r\n      var fcanvas = document.createElement('canvas');\r\n      var fctx = fcanvas.getContext('2d', { willReadFrequently: true });\r\n\r\n      fctx.font = settings.fontWeight + ' ' +\r\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\r\n\r\n      // Estimate the dimension of the text with measureText().\r\n      var fw = fctx.measureText(word).width / mu;\r\n      var fh = Math.max(fontSize * mu,\r\n                        fctx.measureText('m').width,\r\n                        fctx.measureText('\\uFF37').width) / mu;\r\n\r\n      // Create a boundary box that is larger than our estimates,\r\n      // so text don't get cut of (it sill might)\r\n      var boxWidth = fw + fh * 2;\r\n      var boxHeight = fh * 3;\r\n      var fgw = Math.ceil(boxWidth / g);\r\n      var fgh = Math.ceil(boxHeight / g);\r\n      boxWidth = fgw * g;\r\n      boxHeight = fgh * g;\r\n\r\n      // Calculate the proper offsets to make the text centered at\r\n      // the preferred position.\r\n\r\n      // This is simply half of the width.\r\n      var fillTextOffsetX = - fw / 2;\r\n      // Instead of moving the box to the exact middle of the preferred\r\n      // position, for Y-offset we move 0.4 instead, so Latin alphabets look\r\n      // vertical centered.\r\n      var fillTextOffsetY = - fh * 0.4;\r\n\r\n      // Calculate the actual dimension of the canvas, considering the rotation.\r\n      var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) +\r\n                           boxHeight * Math.abs(Math.cos(rotateDeg))) / g);\r\n      var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) +\r\n                           boxHeight * Math.abs(Math.sin(rotateDeg))) / g);\r\n      var width = cgw * g;\r\n      var height = cgh * g;\r\n\r\n      fcanvas.setAttribute('width', width);\r\n      fcanvas.setAttribute('height', height);\r\n\r\n      if (debug) {\r\n        // Attach fcanvas to the DOM\r\n        document.body.appendChild(fcanvas);\r\n        // Save it's state so that we could restore and draw the grid correctly.\r\n        fctx.save();\r\n      }\r\n\r\n      // Scale the canvas with |mu|.\r\n      fctx.scale(1 / mu, 1 / mu);\r\n      fctx.translate(width * mu / 2, height * mu / 2);\r\n      fctx.rotate(- rotateDeg);\r\n\r\n      // Once the width/height is set, ctx info will be reset.\r\n      // Set it again here.\r\n      fctx.font = settings.fontWeight + ' ' +\r\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\r\n\r\n      // Fill the text into the fcanvas.\r\n      // XXX: We cannot because textBaseline = 'top' here because\r\n      // Firefox and Chrome uses different default line-height for canvas.\r\n      // Please read https://bugzil.la/737852#c6.\r\n      // Here, we use textBaseline = 'middle' and draw the text at exactly\r\n      // 0.5 * fontSize lower.\r\n      fctx.fillStyle = '#000';\r\n      fctx.textBaseline = 'middle';\r\n      fctx.fillText(word, fillTextOffsetX * mu,\r\n                    (fillTextOffsetY + fontSize * 0.5) * mu);\r\n\r\n      // Get the pixels of the text\r\n      var imageData = fctx.getImageData(0, 0, width, height).data;\r\n\r\n      if (exceedTime()) {\r\n        return false;\r\n      }\r\n\r\n      if (debug) {\r\n        // Draw the box of the original estimation\r\n        fctx.strokeRect(fillTextOffsetX * mu,\r\n                        fillTextOffsetY, fw * mu, fh * mu);\r\n        fctx.restore();\r\n      }\r\n\r\n      // Read the pixels and save the information to the occupied array\r\n      var occupied = [];\r\n      var gx = cgw, gy, x, y;\r\n      var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];\r\n      while (gx--) {\r\n        gy = cgh;\r\n        while (gy--) {\r\n          y = g;\r\n          singleGridLoop: {\r\n            while (y--) {\r\n              x = g;\r\n              while (x--) {\r\n                if (imageData[((gy * g + y) * width +\r\n                               (gx * g + x)) * 4 + 3]) {\r\n                  occupied.push([gx, gy]);\r\n\r\n                  if (gx < bounds[3]) {\r\n                    bounds[3] = gx;\r\n                  }\r\n                  if (gx > bounds[1]) {\r\n                    bounds[1] = gx;\r\n                  }\r\n                  if (gy < bounds[0]) {\r\n                    bounds[0] = gy;\r\n                  }\r\n                  if (gy > bounds[2]) {\r\n                    bounds[2] = gy;\r\n                  }\r\n\r\n                  if (debug) {\r\n                    fctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\r\n                    fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\r\n                  }\r\n                  break singleGridLoop;\r\n                }\r\n              }\r\n            }\r\n            if (debug) {\r\n              fctx.fillStyle = 'rgba(0, 0, 255, 0.5)';\r\n              fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (debug) {\r\n        fctx.fillStyle = 'rgba(0, 255, 0, 0.5)';\r\n        fctx.fillRect(bounds[3] * g,\r\n                      bounds[0] * g,\r\n                      (bounds[1] - bounds[3] + 1) * g,\r\n                      (bounds[2] - bounds[0] + 1) * g);\r\n      }\r\n\r\n      // Return information needed to create the text on the real canvas\r\n      return {\r\n        mu: mu,\r\n        occupied: occupied,\r\n        bounds: bounds,\r\n        gw: cgw,\r\n        gh: cgh,\r\n        fillTextOffsetX: fillTextOffsetX,\r\n        fillTextOffsetY: fillTextOffsetY,\r\n        fillTextWidth: fw,\r\n        fillTextHeight: fh,\r\n        fontSize: fontSize\r\n      };\r\n    };\r\n\r\n    /* Determine if there is room available in the given dimension */\r\n    var canFitText = function canFitText(gx, gy, gw, gh, occupied) {\r\n      // Go through the occupied points,\r\n      // return false if the space is not available.\r\n      var i = occupied.length;\r\n      while (i--) {\r\n        var px = gx + occupied[i][0];\r\n        var py = gy + occupied[i][1];\r\n\r\n        if (px >= ngx || py >= ngy || px < 0 || py < 0) {\r\n          if (!settings.drawOutOfBound) {\r\n            return false;\r\n          }\r\n          continue;\r\n        }\r\n\r\n        if (!grid[px][py]) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n\r\n    /* Actually draw the text on the grid */\r\n    var drawText = function drawText(gx, gy, info, word, weight,\r\n                                     distance, theta, rotateDeg, attributes) {\r\n\r\n      var fontSize = info.fontSize;\r\n      var color;\r\n      if (getTextColor) {\r\n        color = getTextColor(word, weight, fontSize, distance, theta);\r\n      } else {\r\n        color = settings.color;\r\n      }\r\n\r\n      var classes;\r\n      if (getTextClasses) {\r\n        classes = getTextClasses(word, weight, fontSize, distance, theta);\r\n      } else {\r\n        classes = settings.classes;\r\n      }\r\n\r\n      var dimension;\r\n      var bounds = info.bounds;\r\n      dimension = {\r\n        x: (gx + bounds[3]) * g,\r\n        y: (gy + bounds[0]) * g,\r\n        w: (bounds[1] - bounds[3] + 1) * g,\r\n        h: (bounds[2] - bounds[0] + 1) * g\r\n      };\r\n\r\n      elements.forEach(function(el) {\r\n        if (el.getContext) {\r\n          var ctx = el.getContext('2d');\r\n          var mu = info.mu;\r\n\r\n          // Save the current state before messing it\r\n          ctx.save();\r\n          ctx.scale(1 / mu, 1 / mu);\r\n\r\n          ctx.font = settings.fontWeight + ' ' +\r\n                     (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\r\n          ctx.fillStyle = color;\r\n\r\n          // Translate the canvas position to the origin coordinate of where\r\n          // the text should be put.\r\n          ctx.translate((gx + info.gw / 2) * g * mu,\r\n                        (gy + info.gh / 2) * g * mu);\r\n\r\n          if (rotateDeg !== 0) {\r\n            ctx.rotate(- rotateDeg);\r\n          }\r\n\r\n          // Finally, fill the text.\r\n\r\n          // XXX: We cannot because textBaseline = 'top' here because\r\n          // Firefox and Chrome uses different default line-height for canvas.\r\n          // Please read https://bugzil.la/737852#c6.\r\n          // Here, we use textBaseline = 'middle' and draw the text at exactly\r\n          // 0.5 * fontSize lower.\r\n          ctx.textBaseline = 'middle';\r\n          ctx.fillText(word, info.fillTextOffsetX * mu,\r\n                             (info.fillTextOffsetY + fontSize * 0.5) * mu);\r\n\r\n          // The below box is always matches how <span>s are positioned\r\n          /* ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,\r\n            info.fillTextWidth, info.fillTextHeight); */\r\n\r\n          // Restore the state.\r\n          ctx.restore();\r\n        } else {\r\n          // drawText on DIV element\r\n          var span = document.createElement('span');\r\n          var transformRule = '';\r\n          transformRule = 'rotate(' + (- rotateDeg / Math.PI * 180) + 'deg) ';\r\n          if (info.mu !== 1) {\r\n            transformRule +=\r\n              'translateX(-' + (info.fillTextWidth / 4) + 'px) ' +\r\n              'scale(' + (1 / info.mu) + ')';\r\n          }\r\n          var styleRules = {\r\n            'position': 'absolute',\r\n            'display': 'block',\r\n            'font': settings.fontWeight + ' ' +\r\n                    (fontSize * info.mu) + 'px ' + settings.fontFamily,\r\n            'left': ((gx + info.gw / 2) * g + info.fillTextOffsetX) + 'px',\r\n            'top': ((gy + info.gh / 2) * g + info.fillTextOffsetY) + 'px',\r\n            'width': info.fillTextWidth + 'px',\r\n            'height': info.fillTextHeight + 'px',\r\n            'lineHeight': fontSize + 'px',\r\n            'whiteSpace': 'nowrap',\r\n            'transform': transformRule,\r\n            'webkitTransform': transformRule,\r\n            'msTransform': transformRule,\r\n            'transformOrigin': '50% 40%',\r\n            'webkitTransformOrigin': '50% 40%',\r\n            'msTransformOrigin': '50% 40%'\r\n          };\r\n          if (color) {\r\n            styleRules.color = color;\r\n          }\r\n          span.textContent = word;\r\n          for (var cssProp in styleRules) {\r\n            span.style[cssProp] = styleRules[cssProp];\r\n          }\r\n          if (attributes) {\r\n            for (var attribute in attributes) {\r\n              span.setAttribute(attribute, attributes[attribute]);\r\n            }\r\n          }\r\n          if (classes) {\r\n            span.className += classes;\r\n          }\r\n          el.appendChild(span);\r\n        }\r\n      });\r\n    };\r\n\r\n    /* Help function to updateGrid */\r\n    var fillGridAt = function fillGridAt(x, y, drawMask, dimension, item) {\r\n      if (x >= ngx || y >= ngy || x < 0 || y < 0) {\r\n        return;\r\n      }\r\n\r\n      grid[x][y] = false;\r\n\r\n      if (drawMask) {\r\n        var ctx = elements[0].getContext('2d');\r\n        ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth);\r\n      }\r\n\r\n      if (interactive) {\r\n        infoGrid[x][y] = { item: item, dimension: dimension };\r\n      }\r\n    };\r\n\r\n    /* Update the filling information of the given space with occupied points.\r\n       Draw the mask on the canvas if necessary. */\r\n    var updateGrid = function updateGrid(gx, gy, gw, gh, info, item) {\r\n      var occupied = info.occupied;\r\n      var drawMask = settings.drawMask;\r\n      var ctx;\r\n      if (drawMask) {\r\n        ctx = elements[0].getContext('2d');\r\n        ctx.save();\r\n        ctx.fillStyle = settings.maskColor;\r\n      }\r\n\r\n      var dimension;\r\n      if (interactive) {\r\n        var bounds = info.bounds;\r\n        dimension = {\r\n          x: (gx + bounds[3]) * g,\r\n          y: (gy + bounds[0]) * g,\r\n          w: (bounds[1] - bounds[3] + 1) * g,\r\n          h: (bounds[2] - bounds[0] + 1) * g\r\n        };\r\n      }\r\n\r\n      var i = occupied.length;\r\n      while (i--) {\r\n        var px = gx + occupied[i][0];\r\n        var py = gy + occupied[i][1];\r\n\r\n        if (px >= ngx || py >= ngy || px < 0 || py < 0) {\r\n          continue;\r\n        }\r\n\r\n        fillGridAt(px, py, drawMask, dimension, item);\r\n      }\r\n\r\n      if (drawMask) {\r\n        ctx.restore();\r\n      }\r\n    };\r\n\r\n    /* putWord() processes each item on the list,\r\n       calculate it's size and determine it's position, and actually\r\n       put it on the canvas. */\r\n    var putWord = function putWord(item) {\r\n      var word, weight, attributes;\r\n      if (Array.isArray(item)) {\r\n        word = item[0];\r\n        weight = item[1];\r\n      } else {\r\n        word = item.word;\r\n        weight = item.weight;\r\n        attributes = item.attributes;\r\n      }\r\n      var rotateDeg = getRotateDeg();\r\n\r\n      // get info needed to put the text onto the canvas\r\n      var info = getTextInfo(word, weight, rotateDeg);\r\n\r\n      // not getting the info means we shouldn't be drawing this one.\r\n      if (!info) {\r\n        return false;\r\n      }\r\n\r\n      if (exceedTime()) {\r\n        return false;\r\n      }\r\n\r\n      // If drawOutOfBound is set to false,\r\n      // skip the loop if we have already know the bounding box of\r\n      // word is larger than the canvas.\r\n      if (!settings.drawOutOfBound) {\r\n        var bounds = info.bounds;\r\n        if ((bounds[1] - bounds[3] + 1) > ngx ||\r\n          (bounds[2] - bounds[0] + 1) > ngy) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      // Determine the position to put the text by\r\n      // start looking for the nearest points\r\n      var r = maxRadius + 1;\r\n\r\n      var tryToPutWordAtPoint = function(gxy) {\r\n        var gx = Math.floor(gxy[0] - info.gw / 2);\r\n        var gy = Math.floor(gxy[1] - info.gh / 2);\r\n        var gw = info.gw;\r\n        var gh = info.gh;\r\n\r\n        // If we cannot fit the text at this position, return false\r\n        // and go to the next position.\r\n        if (!canFitText(gx, gy, gw, gh, info.occupied)) {\r\n          return false;\r\n        }\r\n\r\n        // Actually put the text on the canvas\r\n        drawText(gx, gy, info, word, weight,\r\n                 (maxRadius - r), gxy[2], rotateDeg, attributes);\r\n\r\n        // Mark the spaces on the grid as filled\r\n        updateGrid(gx, gy, gw, gh, info, item);\r\n\r\n        return {\r\n          gx: gx,\r\n          gy: gy,\r\n          rot: rotateDeg,\r\n          info: info\r\n        };\r\n      };\r\n\r\n      while (r--) {\r\n        var points = getPointsAtRadius(maxRadius - r);\r\n\r\n        if (settings.shuffle) {\r\n          points = [].concat(points);\r\n          shuffleArray(points);\r\n        }\r\n\r\n        // Try to fit the words by looking at each point.\r\n        // array.some() will stop and return true\r\n        // when putWordAtPoint() returns true.\r\n        for (var i = 0; i < points.length; i++) {\r\n          var res = tryToPutWordAtPoint(points[i]);\r\n          if (res) {\r\n            return res;\r\n          }\r\n        }\r\n\r\n        // var drawn = points.some(tryToPutWordAtPoint);\r\n        // if (drawn) {\r\n        //   // leave putWord() and return true\r\n        //   return true;\r\n        // }\r\n      }\r\n      // we tried all distances but text won't fit, return null\r\n      return null;\r\n    };\r\n\r\n    /* Send DOM event to all elements. Will stop sending event and return\r\n       if the previous one is canceled (for cancelable events). */\r\n    var sendEvent = function sendEvent(type, cancelable, detail) {\r\n      if (cancelable) {\r\n        return !elements.some(function(el) {\r\n          var evt = document.createEvent('CustomEvent');\r\n          evt.initCustomEvent(type, true, cancelable, detail || {});\r\n          return !el.dispatchEvent(evt);\r\n        }, this);\r\n      } else {\r\n        elements.forEach(function(el) {\r\n          var evt = document.createEvent('CustomEvent');\r\n          evt.initCustomEvent(type, true, cancelable, detail || {});\r\n          el.dispatchEvent(evt);\r\n        }, this);\r\n      }\r\n    };\r\n\r\n    /* Start drawing on a canvas */\r\n    var start = function start() {\r\n      // For dimensions, clearCanvas etc.,\r\n      // we only care about the first element.\r\n      var canvas = elements[0];\r\n\r\n      if (canvas.getContext) {\r\n        ngx = Math.ceil(canvas.width / g);\r\n        ngy = Math.ceil(canvas.height / g);\r\n      } else {\r\n        var rect = canvas.getBoundingClientRect();\r\n        ngx = Math.ceil(rect.width / g);\r\n        ngy = Math.ceil(rect.height / g);\r\n      }\r\n\r\n      // Sending a wordcloudstart event which cause the previous loop to stop.\r\n      // Do nothing if the event is canceled.\r\n      if (!sendEvent('wordcloudstart', true)) {\r\n        return;\r\n      }\r\n\r\n      // Determine the center of the word cloud\r\n      center = (settings.origin) ?\r\n        [settings.origin[0]/g, settings.origin[1]/g] :\r\n        [ngx / 2, ngy / 2];\r\n\r\n      // Maxium radius to look for space\r\n      maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));\r\n\r\n      /* Clear the canvas only if the clearCanvas is set,\r\n         if not, update the grid to the current canvas state */\r\n      grid = [];\r\n\r\n      var gx, gy, i;\r\n      if (!canvas.getContext || settings.clearCanvas) {\r\n        elements.forEach(function(el) {\r\n          if (el.getContext) {\r\n            var ctx = el.getContext('2d');\r\n            ctx.fillStyle = settings.backgroundColor;\r\n            ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\r\n            ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\r\n          } else {\r\n            el.textContent = '';\r\n            el.style.backgroundColor = settings.backgroundColor;\r\n            el.style.position = 'relative';\r\n          }\r\n        });\r\n\r\n        /* fill the grid with empty state */\r\n        gx = ngx;\r\n        while (gx--) {\r\n          grid[gx] = [];\r\n          gy = ngy;\r\n          while (gy--) {\r\n            grid[gx][gy] = true;\r\n          }\r\n        }\r\n      } else {\r\n        /* Determine bgPixel by creating\r\n           another canvas and fill the specified background color. */\r\n        var bctx = document.createElement('canvas').getContext('2d');\r\n\r\n        bctx.fillStyle = settings.backgroundColor;\r\n        bctx.fillRect(0, 0, 1, 1);\r\n        var bgPixel = bctx.getImageData(0, 0, 1, 1).data;\r\n\r\n        /* Read back the pixels of the canvas we got to tell which part of the\r\n           canvas is empty.\r\n           (no clearCanvas only works with a canvas, not divs) */\r\n        var imageData =\r\n          canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data;\r\n\r\n        gx = ngx;\r\n        var x, y;\r\n        while (gx--) {\r\n          grid[gx] = [];\r\n          gy = ngy;\r\n          while (gy--) {\r\n            y = g;\r\n            singleGridLoop: while (y--) {\r\n              x = g;\r\n              while (x--) {\r\n                i = 4;\r\n                while (i--) {\r\n                  if (imageData[((gy * g + y) * ngx * g +\r\n                                 (gx * g + x)) * 4 + i] !== bgPixel[i]) {\r\n                    grid[gx][gy] = false;\r\n                    break singleGridLoop;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n            if (grid[gx][gy] !== false) {\r\n              grid[gx][gy] = true;\r\n            }\r\n          }\r\n        }\r\n\r\n        imageData = bctx = bgPixel = undefined;\r\n      }\r\n\r\n      // fill the infoGrid with empty state if we need it\r\n      if (settings.hover || settings.click) {\r\n\r\n        interactive = true;\r\n\r\n        /* fill the grid with empty state */\r\n        gx = ngx + 1;\r\n        while (gx--) {\r\n          infoGrid[gx] = [];\r\n        }\r\n\r\n        if (settings.hover) {\r\n          canvas.addEventListener('mousemove', wordcloudhover);\r\n        }\r\n\r\n        if (settings.click) {\r\n          canvas.addEventListener('click', wordcloudclick);\r\n          canvas.addEventListener('touchstart', wordcloudclick);\r\n          canvas.addEventListener('touchend', function (e) {\r\n            e.preventDefault();\r\n          });\r\n          canvas.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)';\r\n        }\r\n\r\n        canvas.addEventListener('wordcloudstart', function stopInteraction() {\r\n          canvas.removeEventListener('wordcloudstart', stopInteraction);\r\n\r\n          canvas.removeEventListener('mousemove', wordcloudhover);\r\n          canvas.removeEventListener('click', wordcloudclick);\r\n          hovered = undefined;\r\n        });\r\n      }\r\n\r\n      i = 0;\r\n      var loopingFunction, stoppingFunction;\r\n      var layouting = true;\r\n      if (!settings.layoutAnimation) {\r\n        loopingFunction = function (cb) {\r\n          cb();\r\n        }\r\n        stoppingFunction = function () {\r\n          layouting = false;\r\n        }\r\n      }\r\n      else if (settings.wait !== 0) {\r\n        loopingFunction = window.setTimeout;\r\n        stoppingFunction = window.clearTimeout;\r\n      } else {\r\n        loopingFunction = window.setImmediate;\r\n        stoppingFunction = window.clearImmediate;\r\n      }\r\n\r\n      var addEventListener = function addEventListener(type, listener) {\r\n        elements.forEach(function(el) {\r\n          el.addEventListener(type, listener);\r\n        }, this);\r\n      };\r\n\r\n      var removeEventListener = function removeEventListener(type, listener) {\r\n        elements.forEach(function(el) {\r\n          el.removeEventListener(type, listener);\r\n        }, this);\r\n      };\r\n\r\n      var anotherWordCloudStart = function anotherWordCloudStart() {\r\n        removeEventListener('wordcloudstart', anotherWordCloudStart);\r\n        stoppingFunction(timer);\r\n      };\r\n\r\n      addEventListener('wordcloudstart', anotherWordCloudStart);\r\n\r\n      // At least wait the following code before call the first iteration.\r\n      var timer = (settings.layoutAnimation ? loopingFunction : setTimeout)(function loop() {\r\n        if (!layouting) {\r\n          return;\r\n        }\r\n        if (i >= settings.list.length) {\r\n          stoppingFunction(timer);\r\n          sendEvent('wordcloudstop', false);\r\n          removeEventListener('wordcloudstart', anotherWordCloudStart);\r\n\r\n          return;\r\n        }\r\n        escapeTime = (new Date()).getTime();\r\n        var drawn = putWord(settings.list[i]);\r\n        var canceled = !sendEvent('wordclouddrawn', true, {\r\n          item: settings.list[i], drawn: drawn });\r\n        if (exceedTime() || canceled) {\r\n          stoppingFunction(timer);\r\n          settings.abort();\r\n          sendEvent('wordcloudabort', false);\r\n          sendEvent('wordcloudstop', false);\r\n          removeEventListener('wordcloudstart', anotherWordCloudStart);\r\n          return;\r\n        }\r\n        i++;\r\n        timer = loopingFunction(loop, settings.wait);\r\n      }, settings.wait);\r\n    };\r\n\r\n    // All set, start the drawing\r\n    start();\r\n  };\r\n\r\n  WordCloud.isSupported = isSupported;\r\n  WordCloud.minFontSize = minFontSize;\r\n\r\n  export default WordCloud;","import * as echarts from 'echarts/lib/echarts';\r\n\r\nimport './WordCloudSeries';\r\nimport './WordCloudView';\r\n\r\nimport wordCloudLayoutHelper from './layout';\r\n\r\nif (!wordCloudLayoutHelper.isSupported) {\r\n    throw new Error('Sorry your browser not support wordCloud');\r\n}\r\n\r\n// https://github.com/timdream/wordcloud2.js/blob/c236bee60436e048949f9becc4f0f67bd832dc5c/index.js#L233\r\nfunction updateCanvasMask(maskCanvas) {\r\n    var ctx = maskCanvas.getContext('2d');\r\n    var imageData = ctx.getImageData(\r\n        0, 0, maskCanvas.width, maskCanvas.height);\r\n    var newImageData = ctx.createImageData(imageData);\r\n\r\n    var toneSum = 0;\r\n    var toneCnt = 0;\r\n    for (var i = 0; i < imageData.data.length; i += 4) {\r\n        var alpha = imageData.data[i + 3];\r\n        if (alpha > 128) {\r\n            var tone = imageData.data[i]\r\n                + imageData.data[i + 1]\r\n                + imageData.data[i + 2];\r\n            toneSum += tone;\r\n            ++toneCnt;\r\n        }\r\n    }\r\n    var threshold = toneSum / toneCnt;\r\n\r\n    for (var i = 0; i < imageData.data.length; i += 4) {\r\n        var tone = imageData.data[i]\r\n            + imageData.data[i + 1]\r\n            + imageData.data[i + 2];\r\n        var alpha = imageData.data[i + 3];\r\n\r\n        if (alpha < 128 || tone > threshold) {\r\n            // Area not to draw\r\n            newImageData.data[i] = 0;\r\n            newImageData.data[i + 1] = 0;\r\n            newImageData.data[i + 2] = 0;\r\n            newImageData.data[i + 3] = 0;\r\n        }\r\n        else {\r\n            // Area to draw\r\n            // The color must be same with backgroundColor\r\n            newImageData.data[i] = 255;\r\n            newImageData.data[i + 1] = 255;\r\n            newImageData.data[i + 2] = 255;\r\n            newImageData.data[i + 3] = 255;\r\n        }\r\n    }\r\n\r\n    ctx.putImageData(newImageData, 0, 0);\r\n}\r\n\r\necharts.registerLayout(function (ecModel, api) {\r\n    ecModel.eachSeriesByType('wordCloud', function (seriesModel) {\r\n        var gridRect = echarts.helper.getLayoutRect(\r\n            seriesModel.getBoxLayoutParams(), {\r\n                width: api.getWidth(),\r\n                height: api.getHeight()\r\n            }\r\n        );\r\n        var data = seriesModel.getData();\r\n\r\n        var canvas = document.createElement('canvas');\r\n        canvas.width = gridRect.width;\r\n        canvas.height = gridRect.height;\r\n\r\n        var ctx = canvas.getContext('2d');\r\n        var maskImage = seriesModel.get('maskImage');\r\n        if (maskImage) {\r\n            try {\r\n                ctx.drawImage(maskImage, 0, 0, canvas.width, canvas.height);\r\n                updateCanvasMask(canvas);\r\n            }\r\n            catch (e) {\r\n                console.error('Invalid mask image');\r\n                console.error(e.toString());\r\n            }\r\n        }\r\n\r\n        var sizeRange = seriesModel.get('sizeRange');\r\n        var rotationRange = seriesModel.get('rotationRange');\r\n        var valueExtent = data.getDataExtent('value');\r\n\r\n        var DEGREE_TO_RAD = Math.PI / 180;\r\n        var gridSize = seriesModel.get('gridSize');\r\n        wordCloudLayoutHelper(canvas, {\r\n            list: data.mapArray('value', function (value, idx) {\r\n                var itemModel = data.getItemModel(idx);\r\n                return [\r\n                    data.getName(idx),\r\n                    itemModel.get('textStyle.fontSize', true)\r\n                        || echarts.number.linearMap(value, valueExtent, sizeRange),\r\n                    idx\r\n                ];\r\n            }).sort(function (a, b) {\r\n                // Sort from large to small in case there is no more room for more words\r\n                return b[1] - a[1];\r\n            }),\r\n            fontFamily: seriesModel.get('textStyle.fontFamily')\r\n                || seriesModel.get('emphasis.textStyle.fontFamily')\r\n                || ecModel.get('textStyle.fontFamily'),\r\n            fontWeight: seriesModel.get('textStyle.fontWeight')\r\n                || seriesModel.get('emphasis.textStyle.fontWeight')\r\n                || ecModel.get('textStyle.fontWeight'),\r\n\r\n            gridSize: gridSize,\r\n\r\n            ellipticity: gridRect.height / gridRect.width,\r\n\r\n            minRotation: rotationRange[0] * DEGREE_TO_RAD,\r\n            maxRotation: rotationRange[1] * DEGREE_TO_RAD,\r\n\r\n            clearCanvas: !maskImage,\r\n\r\n            rotateRatio: 1,\r\n\r\n            rotationStep: seriesModel.get('rotationStep') * DEGREE_TO_RAD,\r\n\r\n            drawOutOfBound: seriesModel.get('drawOutOfBound'),\r\n\r\n            layoutAnimation: seriesModel.get('layoutAnimation'),\r\n\r\n            shuffle: false,\r\n\r\n            shape: seriesModel.get('shape')\r\n        });\r\n\r\n        function onWordCloudDrawn(e) {\r\n            var item = e.detail.item;\r\n            if (e.detail.drawn && seriesModel.layoutInstance.ondraw) {\r\n                e.detail.drawn.gx += gridRect.x / gridSize;\r\n                e.detail.drawn.gy += gridRect.y / gridSize;\r\n                seriesModel.layoutInstance.ondraw(\r\n                    item[0], item[1], item[2], e.detail.drawn\r\n                );\r\n            }\r\n        }\r\n\r\n        canvas.addEventListener('wordclouddrawn', onWordCloudDrawn);\r\n\r\n        if (seriesModel.layoutInstance) {\r\n            // Dispose previous\r\n            seriesModel.layoutInstance.dispose();\r\n        }\r\n\r\n        seriesModel.layoutInstance = {\r\n            ondraw: null,\r\n\r\n            dispose: function () {\r\n                canvas.removeEventListener('wordclouddrawn', onWordCloudDrawn);\r\n                // Abort\r\n                canvas.addEventListener('wordclouddrawn', function (e) {\r\n                    // Prevent default to cancle the event and stop the loop\r\n                    e.preventDefault();\r\n                });\r\n            }\r\n        };\r\n    });\r\n});\r\n\r\necharts.registerPreprocessor(function (option) {\r\n    var series = (option || {}).series;\r\n    !echarts.util.isArray(series) && (series = series ? [series] : []);\r\n\r\n    var compats = ['shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];\r\n\r\n    echarts.util.each(series, function (seriesItem) {\r\n        if (seriesItem && seriesItem.type === 'wordCloud') {\r\n            var textStyle = seriesItem.textStyle || {};\r\n\r\n            compatTextStyle(textStyle.normal);\r\n            compatTextStyle(textStyle.emphasis);\r\n        }\r\n    });\r\n\r\n    function compatTextStyle(textStyle) {\r\n        textStyle && echarts.util.each(compats, function (key) {\r\n            if (textStyle.hasOwnProperty(key)) {\r\n                textStyle['text' + echarts.format.capitalFirst(key)] = textStyle[key];\r\n            }\r\n        });\r\n    }\r\n});\r\n","import './src/wordCloud';\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE_echarts_lib_echarts__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(\"./index.js\");\n"],"sourceRoot":""}